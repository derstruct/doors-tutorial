package catalog

import (
	"context"
	"github.com/derstruct/doors-tutorial/common"
	"github.com/derstruct/doors-tutorial/driver"
	"github.com/doors-dev/doors"
)

type Path = common.CatalogPath

type catalogPage struct {
	path    doors.SourceBeam[Path]
	session *driver.Session
}

type metaState struct {
	Cat  string
	Item int
}

func (c *catalogPage) Head() templ.Component {
	state := doors.NewBeam(c.path, func(p Path) metaState {
		if p.IsMain {
			return metaState{
				Cat:  "",
				Item: -1,
			}
		}
		if p.IsCat {
			return metaState{
				Cat:  p.CatId,
				Item: -1,
			}
		}
		return metaState{
			Cat:  p.CatId,
			Item: p.ItemId,
		}
	})
	return doors.Head(state, func(m metaState) doors.HeadData {
		if m.Cat == "" {
			return doors.HeadData{
				Title: "Catalog",
			}
		}
		cat, ok := driver.Cats.Get(m.Cat)
		if !ok {
			return doors.HeadData{
				Title: "Category Not Found",
			}
		}
		if m.Item == -1 {
			return doors.HeadData{
				Title: cat.Name,
				Meta: map[string]string{
					"description": cat.Desc,
				},
			}
		}
		item, ok := driver.Items.Get(m.Item)
		if !ok {
			return doors.HeadData{
				Title: "Item Not Found",
			}
		}
		return doors.HeadData{
			Title: item.Name,
			Meta: map[string]string{
				"description": item.Desc,
			},
		}
	})
}

func (c *catalogPage) Body() templ.Component {
	// wrap in "Evaluate" component to get access to the context
	return doors.E(func(ctx context.Context) templ.Component {

        // insert session
		common.StoreSession(ctx, c.session)

        // everyting else is same
		b := doors.NewBeam(c.path, func(p Path) bool {
			return p.IsMain
		})
		return doors.Sub(b, func(isMain bool) templ.Component {
			if isMain {
				return main()
			}
			return category(c.path)
		})
	})
}

/*
Instead of doing this:

templ (c *catalogPage) Render(b doors.SourceBeam[Path]) {
	@common.Template(c)
}

Because there is only one component `common.Template(c)`, we can return it directly:
*/

func (c *catalogPage) Render(b doors.SourceBeam[Path]) templ.Component {
    c.path = b
    return common.Template(c)
}

// page request handler
func Handler(p doors.PageRouter[Path], r doors.RPage[Path]) doors.PageRoute {
	return p.Page(&catalogPage{
		session: common.GetSession(r),
	})
}
