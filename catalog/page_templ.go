// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.924
package catalog

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

import (
	"context"
	"github.com/derstruct/doors-tutorial/common"
	"github.com/derstruct/doors-tutorial/driver"
	"github.com/doors-dev/doors"
)

type Path = common.CatalogPath

type catalogPage struct {
	path    doors.SourceBeam[Path]
	session *driver.Session
}

type metaState struct {
	Cat  string
	Item int
}

func (c *catalogPage) Head() templ.Component {
	state := doors.NewBeam(c.path, func(p Path) metaState {
		if p.IsMain {
			return metaState{
				Cat:  "",
				Item: -1,
			}
		}
		if p.IsCat {
			return metaState{
				Cat:  p.CatId,
				Item: -1,
			}
		}
		return metaState{
			Cat:  p.CatId,
			Item: p.ItemId,
		}
	})
	return doors.Head(state, func(m metaState) doors.HeadData {
		if m.Cat == "" {
			return doors.HeadData{
				Title: "Catalog",
			}
		}
		cat, ok := driver.Cats.Get(m.Cat)
		if !ok {
			return doors.HeadData{
				Title: "Category Not Found",
			}
		}
		if m.Item == -1 {
			return doors.HeadData{
				Title: cat.Name,
				Meta: map[string]string{
					"description": cat.Desc,
				},
			}
		}
		item, ok := driver.Items.Get(m.Item)
		if !ok {
			return doors.HeadData{
				Title: "Item Not Found",
			}
		}
		return doors.HeadData{
			Title: item.Name,
			Meta: map[string]string{
				"description": item.Desc,
			},
		}
	})
}

func (c *catalogPage) Body() templ.Component {
	// wrap in "Evaluate" component to get access to the context
	return doors.E(func(ctx context.Context) templ.Component {

		// insert session
		common.StoreSession(ctx, c.session)

		// everyting else is same
		b := doors.NewBeam(c.path, func(p Path) bool {
			return p.IsMain
		})
		return doors.Sub(b, func(isMain bool) templ.Component {
			if isMain {
				return main()
			}
			return category(c.path)
		})
	})
}

/*
Instead of doing this:

func (c *catalogPage) Render(b doors.SourceBeam[Path]) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = common.Template(c).Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

Because there is only one component `common.Template(c)`, we can return it directly:
*/

func (c *catalogPage) Render(b doors.SourceBeam[Path]) templ.Component {
	c.path = b
	return common.Template(c)
}

// page request handler
func Handler(p doors.PageRouter[Path], r doors.RPage[Path]) doors.PageRoute {
	return p.Page(&catalogPage{
		session: common.GetSession(r),
	})
}

var _ = templruntime.GeneratedTemplate
